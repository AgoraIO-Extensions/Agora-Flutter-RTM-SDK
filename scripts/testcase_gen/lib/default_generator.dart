import 'package:paraphrase/paraphrase.dart';
import 'package:testcase_gen/generator.dart';

const ignoreForFile = '// ignore_for_file: '
    'deprecated_member_use,'
    'constant_identifier_names,'
    'unused_local_variable,'
    'unused_import,'
    'unnecessary_import';

const defaultHeader = '''
/// GENERATED BY testcase_gen. DO NOT MODIFY BY HAND.

$ignoreForFile
''';

abstract class DefaultGenerator implements Generator {
  const DefaultGenerator();

  GeneratorConfig? getConfig(List<GeneratorConfig> configs, String methodName) {
    for (final config in configs) {
      if (config.name == methodName) {
        return config;
      }
    }
    return null;
  }

  String _concatParamName(String? prefix, String name) {
    if (prefix == null) return name;
    return '$prefix${name[0].toUpperCase()}${name.substring(1)}';
  }

  String getParamType(Parameter parameter) {
    if (parameter.type.typeArguments.isEmpty) {
      return parameter.type.type;
    }

    return '${parameter.type.type}<${parameter.type.typeArguments.map((e) => e.type).join(', ')}>';
  }

  bool _isPrimitiveType(Type type) =>
      type.type == 'int' ||
      type.type == 'double' ||
      type.type == 'bool' ||
      type.type == 'String' ||
      type.type == 'List' ||
      type.type == 'Map' ||
      type.type == 'Set' ||
      type.type == 'Uint8List';

  String defualtValueOfType(
    Type type,
  ) {
    switch (type.type) {
      case 'int':
        return '5';
      case 'double':
        return '5.0';
      case 'String':
        return '"hello"';
      case 'bool':
        return 'true';
      case 'List':
        if (type.typeArguments.isNotEmpty) {
          final typeArgumentType = Type()..type = type.typeArguments[0].type;
          if (_isPrimitiveType(typeArgumentType)) {
            return 'List.filled(5, ${defualtValueOfType(typeArgumentType)})';
          } else {
            return '[]';
          }
        }
        return '[]';
      case 'Map':
        return '{}';
      case 'Uint8List':
        return 'Uint8List.fromList([1, 1, 1, 1, 1])';
      case 'Set':
        return '{}';

      default:
        throw Exception('not support type $type');
    }
  }

  String createListBuilderBlockForList(
      ParseResult parseResult, Parameter parameter) {
    if (parameter.type.typeArguments.isNotEmpty) {
      final listTypeArgumentType = parameter.type.typeArguments[0];
      final listTypeArgumentTypeClazzes =
          parseResult.getClazz(listTypeArgumentType.type);
      if (listTypeArgumentTypeClazzes.isNotEmpty) {
        final clazz = listTypeArgumentTypeClazzes[0];
        final toParamType = Type()..type = clazz.name;
        Parameter pp = Parameter()
          ..type = toParamType
          ..name = '${parameter.name}Item';
        final listInitializerBuilder = StringBuffer();
        createConstructorInitializerForMethodParameter(
            parseResult, null, pp, listInitializerBuilder);
        final listBuilder = '''
final ${getParamType(parameter)} ${parameter.name} = () {
${listInitializerBuilder.toString()}

  return List.filled(5, ${parameter.name}Item);
}();
''';
        return listBuilder;
      }
    }
    return '${getParamType(parameter)} ${parameter.name} = ${defualtValueOfType(parameter.type)};';
  }

  String createConstructorInitializerForMethodParameter(
    ParseResult parseResult,
    Parameter? rootParameter,
    Parameter parameter,
    StringBuffer initializerBuilder,
  ) {
    final bool isEnum = parseResult.hasEnum(parameter.type.type);

    if (isEnum) {
      final enumz = parseResult.getEnum(parameter.type.type)[0];

      initializerBuilder.writeln(
          '${getParamType(parameter)} ${_concatParamName(rootParameter?.name, parameter.name)} = ${enumz.enumConstants[0].name};');

      return _concatParamName(rootParameter?.name, parameter.name);
    }

    final parameterClass = parseResult.getClazz(parameter.type.type)[0];
    final initBlockParameterListBuilder = StringBuffer();
    final initBlockBuilder = StringBuffer();

    bool isNullable = false;
    if (parameterClass.constructors.isEmpty) {
      // If there're not constructors found, default to null.
      isNullable = true;
      initBlockBuilder.write('null');
    } else {
      initBlockBuilder.write(parameterClass.name);
      initBlockBuilder.write('(');

      for (final cp in parameterClass.constructors[0].parameters) {
        final adjustedParamName = _concatParamName(parameter.name, cp.name);
        if (cp.isNamed) {
          if (cp.type.type == 'Function') {
            final functionParamsList = cp.type.parameters
                .map((t) => '${t.type.type} ${t.name}')
                .join(', ');

            initBlockBuilder.write('${cp.name}:($functionParamsList) { },');
          } else if (cp.isPrimitiveType) {
            if (getParamType(cp) == 'Uint8List') {
              initBlockParameterListBuilder.writeln(
                  '${getParamType(cp)} $adjustedParamName = ${defualtValueOfType(cp.type)};');
            } else {
              if (getParamType(cp).startsWith('List') &&
                  parameter.type.typeArguments.isNotEmpty) {
                final listBuilderBlock =
                    createListBuilderBlockForList(parseResult, parameter);
                initBlockParameterListBuilder.writeln(listBuilderBlock);
              } else {
                initBlockParameterListBuilder.writeln(
                    '${getParamType(cp)} $adjustedParamName = ${defualtValueOfType(cp.type)};');
              }
            }

            initBlockBuilder.write('${cp.name}: $adjustedParamName,');
          } else {
            createConstructorInitializerForMethodParameter(
                parseResult, parameter, cp, initializerBuilder);
            initBlockBuilder.write('${cp.name}: $adjustedParamName,');
          }
        } else {
          if (cp.type.type == 'Function') {
            final functionParamsList = cp.type.parameters
                .map((t) => '${t.type.type} ${t.name}')
                .join(', ');

            initBlockBuilder.write('${cp.name}:($functionParamsList) { },');
          } else if (cp.isPrimitiveType) {
            if (getParamType(cp) == 'Uint8List') {
              initBlockParameterListBuilder.writeln(
                  '${getParamType(cp)} $adjustedParamName = ${defualtValueOfType(cp.type)};');
            } else {
              if (getParamType(cp).startsWith('List') &&
                  parameter.type.typeArguments.isNotEmpty) {
                final listBuilderBlock =
                    createListBuilderBlockForList(parseResult, parameter);
                initBlockParameterListBuilder.writeln(listBuilderBlock);
              } else {
                initBlockParameterListBuilder.writeln(
                    '${getParamType(cp)} $adjustedParamName = ${defualtValueOfType(cp.type)};');
              }
            }

            initBlockBuilder.write('$adjustedParamName,');
          } else {
            createConstructorInitializerForMethodParameter(
                parseResult, parameter, cp, initializerBuilder);
            initBlockBuilder.write('$adjustedParamName,');
          }
        }
      }

      initBlockBuilder.write(')');
    }

    initializerBuilder.write(initBlockParameterListBuilder.toString());

    initializerBuilder.writeln(
        '${getParamType(parameter)}${isNullable ? '?' : ''} ${_concatParamName(rootParameter?.name, parameter.name)} = ${initBlockBuilder.toString()};');
    return _concatParamName(rootParameter?.name, parameter.name);
  }
}
