/// GENERATED BY testcase_gen. DO NOT MODIFY BY HAND.

// ignore_for_file: deprecated_member_use,constant_identifier_names,unused_local_variable,unused_import,unnecessary_import

import 'dart:async';
import 'dart:typed_data';

import 'package:agora_rtm/agora_rtm.dart' show AgoraRtmException;
import 'package:agora_rtm/src/bindings/gen/binding_forward_export.dart';
import 'package:agora_rtm/src/impl/rtm_result_handler_impl.dart';
import 'package:agora_rtm/src/bindings/native_iris_api_engine_binding_delegate.dart';
import 'package:agora_rtm/src/bindings/agora_rtm_client_impl_override.dart';
import 'event_ids_mapping_gen.dart';

import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:iris_tester/iris_tester.dart';
import 'package:iris_method_channel/iris_method_channel.dart';

void testCases(
    ValueGetter<IrisTester> irisTester,
    ValueGetter<List<InitilizationArgProvider>>
        irisMethodChannelInitilizationArgs) {
  Future<RtmClientImplOverride> _createBindingRtmClient(
      RtmEventHandler rtmEventHandler) async {
    String appId = const String.fromEnvironment('TEST_APP_ID',
        defaultValue: '<YOUR_APP_ID>');
    final rtmResultHandler = RtmResultHandlerImpl();
    final client = RtmClientImplOverride.create(
      IrisMethodChannel(IrisApiEngineNativeBindingDelegateProvider()),
    );
    await client.initialize(
      appId,
      'user_id',
      rtmResultHandler.rtmEventHandler,
      args: irisMethodChannelInitilizationArgs(),
    );
    return client;
  }

  testWidgets(
    'RtmEventHandler.onLinkStateEvent',
    (WidgetTester tester) async {
      final onLinkStateEventCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onLinkStateEvent: (LinkStateEvent event) {
          onLinkStateEventCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        RtmLinkState eventCurrentState = RtmLinkState.idle;
        RtmLinkState eventPreviousState = RtmLinkState.idle;
        RtmServiceType eventServiceType = RtmServiceType.none;
        RtmLinkOperation eventOperation = RtmLinkOperation.login;
        String eventReason = "hello";
        List<String> eventAffectedChannels = List.filled(5, "hello");
        List<String> eventUnrestoredChannels = List.filled(5, "hello");
        bool eventIsResumed = true;
        int eventTimestamp = 5;
        LinkStateEvent event = LinkStateEvent(
          currentState: eventCurrentState,
          previousState: eventPreviousState,
          serviceType: eventServiceType,
          operation: eventOperation,
          reason: eventReason,
          affectedChannels: eventAffectedChannels,
          unrestoredChannels: eventUnrestoredChannels,
          isResumed: eventIsResumed,
          timestamp: eventTimestamp,
        );

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onLinkStateEvent'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onLinkStateEventCompleter.isCompleted) {
              onLinkStateEventCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onLinkStateEventCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onMessageEvent',
    (WidgetTester tester) async {
      final onMessageEventCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onMessageEvent: (MessageEvent event) {
          onMessageEventCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        RtmChannelType eventChannelType = RtmChannelType.none;
        RtmMessageType eventMessageType = RtmMessageType.binary;
        String eventChannelName = "hello";
        String eventChannelTopic = "hello";
        Uint8List eventMessage = Uint8List.fromList([1, 1, 1, 1, 1]);
        int eventMessageLength = 5;
        String eventPublisher = "hello";
        String eventCustomType = "hello";
        int eventTimestamp = 5;
        MessageEvent event = MessageEvent(
          channelType: eventChannelType,
          messageType: eventMessageType,
          channelName: eventChannelName,
          channelTopic: eventChannelTopic,
          message: eventMessage,
          messageLength: eventMessageLength,
          publisher: eventPublisher,
          customType: eventCustomType,
          timestamp: eventTimestamp,
        );

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onMessageEvent'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onMessageEventCompleter.isCompleted) {
              onMessageEventCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onMessageEventCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onPresenceEvent',
    (WidgetTester tester) async {
      final onPresenceEventCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onPresenceEvent: (PresenceEvent event) {
          onPresenceEventCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        RtmPresenceEventType eventType = RtmPresenceEventType.none;
        RtmChannelType eventChannelType = RtmChannelType.none;
        List<String> joinUserListUsers = List.filled(5, "hello");
        UserList intervalJoinUserList = UserList(
          users: joinUserListUsers,
        );
        List<String> leaveUserListUsers = List.filled(5, "hello");
        UserList intervalLeaveUserList = UserList(
          users: leaveUserListUsers,
        );
        List<String> timeoutUserListUsers = List.filled(5, "hello");
        UserList intervalTimeoutUserList = UserList(
          users: timeoutUserListUsers,
        );
        List<UserState> intervalUserStateList = [];
        IntervalInfo eventInterval = IntervalInfo(
          joinUserList: intervalJoinUserList,
          leaveUserList: intervalLeaveUserList,
          timeoutUserList: intervalTimeoutUserList,
          userStateList: intervalUserStateList,
        );
        List<UserState> snapshotUserStateList = [];
        SnapshotInfo eventSnapshot = SnapshotInfo(
          userStateList: snapshotUserStateList,
        );
        String eventChannelName = "hello";
        String eventPublisher = "hello";
        List<StateItem> eventStateItems = [];
        int eventTimestamp = 5;
        PresenceEvent event = PresenceEvent(
          type: eventType,
          channelType: eventChannelType,
          channelName: eventChannelName,
          publisher: eventPublisher,
          stateItems: eventStateItems,
          interval: eventInterval,
          snapshot: eventSnapshot,
          timestamp: eventTimestamp,
        );

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onPresenceEvent'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onPresenceEventCompleter.isCompleted) {
              onPresenceEventCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onPresenceEventCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onTopicEvent',
    (WidgetTester tester) async {
      final onTopicEventCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onTopicEvent: (TopicEvent event) {
          onTopicEventCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        RtmTopicEventType eventType = RtmTopicEventType.none;
        String eventChannelName = "hello";
        String eventPublisher = "hello";
        List<TopicInfo> eventTopicInfos = [];
        int eventTimestamp = 5;
        TopicEvent event = TopicEvent(
          type: eventType,
          channelName: eventChannelName,
          publisher: eventPublisher,
          topicInfos: eventTopicInfos,
          timestamp: eventTimestamp,
        );

        final eventJson = {};

        final eventIds = eventIdsMapping['RtmEventHandler_onTopicEvent'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onTopicEventCompleter.isCompleted) {
              onTopicEventCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onTopicEventCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onLockEvent',
    (WidgetTester tester) async {
      final onLockEventCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onLockEvent: (LockEvent event) {
          onLockEventCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        RtmChannelType eventChannelType = RtmChannelType.none;
        RtmLockEventType eventEventType = RtmLockEventType.none;
        String eventChannelName = "hello";
        List<LockDetail> eventLockDetailList = [];
        int eventTimestamp = 5;
        LockEvent event = LockEvent(
          channelType: eventChannelType,
          eventType: eventEventType,
          channelName: eventChannelName,
          lockDetailList: eventLockDetailList,
          timestamp: eventTimestamp,
        );

        final eventJson = {};

        final eventIds = eventIdsMapping['RtmEventHandler_onLockEvent'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onLockEventCompleter.isCompleted) {
              onLockEventCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onLockEventCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onStorageEvent',
    (WidgetTester tester) async {
      final onStorageEventCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onStorageEvent: (StorageEvent event) {
          onStorageEventCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        RtmChannelType eventChannelType = RtmChannelType.none;
        RtmStorageType eventStorageType = RtmStorageType.none;
        RtmStorageEventType eventEventType = RtmStorageEventType.none;
        int dataMajorRevision = 5;
        List<MetadataItem> dataItems = [];
        int dataItemCount = 5;
        Metadata eventData = Metadata(
          majorRevision: dataMajorRevision,
          items: dataItems,
          itemCount: dataItemCount,
        );
        String eventTarget = "hello";
        int eventTimestamp = 5;
        StorageEvent event = StorageEvent(
          channelType: eventChannelType,
          storageType: eventStorageType,
          eventType: eventEventType,
          target: eventTarget,
          data: eventData,
          timestamp: eventTimestamp,
        );

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onStorageEvent'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onStorageEventCompleter.isCompleted) {
              onStorageEventCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onStorageEventCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onJoinResult',
    (WidgetTester tester) async {
      final onJoinResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onJoinResult: (int requestId, String channelName, String userId,
            RtmErrorCode errorCode) {
          onJoinResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        String channelName = "hello";
        String userId = "hello";
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds = eventIdsMapping['RtmEventHandler_onJoinResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onJoinResultCompleter.isCompleted) {
              onJoinResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onJoinResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onLeaveResult',
    (WidgetTester tester) async {
      final onLeaveResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onLeaveResult: (int requestId, String channelName, String userId,
            RtmErrorCode errorCode) {
          onLeaveResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        String channelName = "hello";
        String userId = "hello";
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds = eventIdsMapping['RtmEventHandler_onLeaveResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onLeaveResultCompleter.isCompleted) {
              onLeaveResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onLeaveResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onPublishTopicMessageResult',
    (WidgetTester tester) async {
      final onPublishTopicMessageResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onPublishTopicMessageResult: (int requestId, String channelName,
            String topic, RtmErrorCode errorCode) {
          onPublishTopicMessageResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        String channelName = "hello";
        String topic = "hello";
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onPublishTopicMessageResult'] ??
                [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onPublishTopicMessageResultCompleter.isCompleted) {
              onPublishTopicMessageResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onPublishTopicMessageResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onJoinTopicResult',
    (WidgetTester tester) async {
      final onJoinTopicResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onJoinTopicResult: (int requestId, String channelName, String userId,
            String topic, String meta, RtmErrorCode errorCode) {
          onJoinTopicResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        String channelName = "hello";
        String userId = "hello";
        String topic = "hello";
        String meta = "hello";
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onJoinTopicResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onJoinTopicResultCompleter.isCompleted) {
              onJoinTopicResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onJoinTopicResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onLeaveTopicResult',
    (WidgetTester tester) async {
      final onLeaveTopicResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onLeaveTopicResult: (int requestId, String channelName, String userId,
            String topic, String meta, RtmErrorCode errorCode) {
          onLeaveTopicResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        String channelName = "hello";
        String userId = "hello";
        String topic = "hello";
        String meta = "hello";
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onLeaveTopicResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onLeaveTopicResultCompleter.isCompleted) {
              onLeaveTopicResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onLeaveTopicResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onSubscribeTopicResult',
    (WidgetTester tester) async {
      final onSubscribeTopicResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onSubscribeTopicResult: (int requestId,
            String channelName,
            String userId,
            String topic,
            UserList succeedUsers,
            UserList failedUsers,
            RtmErrorCode errorCode) {
          onSubscribeTopicResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        String channelName = "hello";
        String userId = "hello";
        String topic = "hello";
        List<String> succeedUsersUsers = List.filled(5, "hello");
        UserList succeedUsers = UserList(
          users: succeedUsersUsers,
        );
        List<String> failedUsersUsers = List.filled(5, "hello");
        UserList failedUsers = UserList(
          users: failedUsersUsers,
        );
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onSubscribeTopicResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onSubscribeTopicResultCompleter.isCompleted) {
              onSubscribeTopicResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onSubscribeTopicResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onUnsubscribeTopicResult',
    (WidgetTester tester) async {
      final onUnsubscribeTopicResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onUnsubscribeTopicResult: (int requestId, String channelName,
            String topic, RtmErrorCode errorCode) {
          onUnsubscribeTopicResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        String channelName = "hello";
        String topic = "hello";
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onUnsubscribeTopicResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onUnsubscribeTopicResultCompleter.isCompleted) {
              onUnsubscribeTopicResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onUnsubscribeTopicResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onGetSubscribedUserListResult',
    (WidgetTester tester) async {
      final onGetSubscribedUserListResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onGetSubscribedUserListResult: (int requestId, String channelName,
            String topic, UserList users, RtmErrorCode errorCode) {
          onGetSubscribedUserListResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        String channelName = "hello";
        String topic = "hello";
        List<String> usersUsers = List.filled(5, "hello");
        UserList users = UserList(
          users: usersUsers,
        );
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onGetSubscribedUserListResult'] ??
                [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onGetSubscribedUserListResultCompleter.isCompleted) {
              onGetSubscribedUserListResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onGetSubscribedUserListResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onConnectionStateChanged',
    (WidgetTester tester) async {
      final onConnectionStateChangedCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onConnectionStateChanged: (String channelName, RtmConnectionState state,
            RtmConnectionChangeReason reason) {
          onConnectionStateChangedCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        String channelName = "hello";
        RtmConnectionState state = RtmConnectionState.disconnected;
        RtmConnectionChangeReason reason = RtmConnectionChangeReason.connecting;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onConnectionStateChanged'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onConnectionStateChangedCompleter.isCompleted) {
              onConnectionStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onConnectionStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onTokenPrivilegeWillExpire',
    (WidgetTester tester) async {
      final onTokenPrivilegeWillExpireCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onTokenPrivilegeWillExpire: (String channelName) {
          onTokenPrivilegeWillExpireCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        String channelName = "hello";

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onTokenPrivilegeWillExpire'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onTokenPrivilegeWillExpireCompleter.isCompleted) {
              onTokenPrivilegeWillExpireCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onTokenPrivilegeWillExpireCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onSubscribeResult',
    (WidgetTester tester) async {
      final onSubscribeResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onSubscribeResult:
            (int requestId, String channelName, RtmErrorCode errorCode) {
          onSubscribeResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        String channelName = "hello";
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onSubscribeResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onSubscribeResultCompleter.isCompleted) {
              onSubscribeResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onSubscribeResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onUnsubscribeResult',
    (WidgetTester tester) async {
      final onUnsubscribeResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onUnsubscribeResult:
            (int requestId, String channelName, RtmErrorCode errorCode) {
          onUnsubscribeResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        String channelName = "hello";
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onUnsubscribeResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onUnsubscribeResultCompleter.isCompleted) {
              onUnsubscribeResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onUnsubscribeResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onPublishResult',
    (WidgetTester tester) async {
      final onPublishResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onPublishResult: (int requestId, RtmErrorCode errorCode) {
          onPublishResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onPublishResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onPublishResultCompleter.isCompleted) {
              onPublishResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onPublishResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onLoginResult',
    (WidgetTester tester) async {
      final onLoginResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onLoginResult: (int requestId, RtmErrorCode errorCode) {
          onLoginResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds = eventIdsMapping['RtmEventHandler_onLoginResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onLoginResultCompleter.isCompleted) {
              onLoginResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onLoginResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onLogoutResult',
    (WidgetTester tester) async {
      final onLogoutResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onLogoutResult: (int requestId, RtmErrorCode errorCode) {
          onLogoutResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onLogoutResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onLogoutResultCompleter.isCompleted) {
              onLogoutResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onLogoutResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onRenewTokenResult',
    (WidgetTester tester) async {
      final onRenewTokenResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onRenewTokenResult: (int requestId, RtmServiceType serverType,
            String channelName, RtmErrorCode errorCode) {
          onRenewTokenResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        RtmServiceType serverType = RtmServiceType.none;
        String channelName = "hello";
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onRenewTokenResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onRenewTokenResultCompleter.isCompleted) {
              onRenewTokenResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRenewTokenResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onSetChannelMetadataResult',
    (WidgetTester tester) async {
      final onSetChannelMetadataResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onSetChannelMetadataResult: (int requestId, String channelName,
            RtmChannelType channelType, RtmErrorCode errorCode) {
          onSetChannelMetadataResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        String channelName = "hello";
        RtmChannelType channelType = RtmChannelType.none;
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onSetChannelMetadataResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onSetChannelMetadataResultCompleter.isCompleted) {
              onSetChannelMetadataResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onSetChannelMetadataResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onUpdateChannelMetadataResult',
    (WidgetTester tester) async {
      final onUpdateChannelMetadataResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onUpdateChannelMetadataResult: (int requestId, String channelName,
            RtmChannelType channelType, RtmErrorCode errorCode) {
          onUpdateChannelMetadataResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        String channelName = "hello";
        RtmChannelType channelType = RtmChannelType.none;
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onUpdateChannelMetadataResult'] ??
                [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onUpdateChannelMetadataResultCompleter.isCompleted) {
              onUpdateChannelMetadataResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onUpdateChannelMetadataResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onRemoveChannelMetadataResult',
    (WidgetTester tester) async {
      final onRemoveChannelMetadataResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onRemoveChannelMetadataResult: (int requestId, String channelName,
            RtmChannelType channelType, RtmErrorCode errorCode) {
          onRemoveChannelMetadataResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        String channelName = "hello";
        RtmChannelType channelType = RtmChannelType.none;
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onRemoveChannelMetadataResult'] ??
                [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onRemoveChannelMetadataResultCompleter.isCompleted) {
              onRemoveChannelMetadataResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRemoveChannelMetadataResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onGetChannelMetadataResult',
    (WidgetTester tester) async {
      final onGetChannelMetadataResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onGetChannelMetadataResult: (int requestId, String channelName,
            RtmChannelType channelType, Metadata data, RtmErrorCode errorCode) {
          onGetChannelMetadataResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        String channelName = "hello";
        RtmChannelType channelType = RtmChannelType.none;
        int dataMajorRevision = 5;
        List<MetadataItem> dataItems = [];
        int dataItemCount = 5;
        Metadata data = Metadata(
          majorRevision: dataMajorRevision,
          items: dataItems,
          itemCount: dataItemCount,
        );
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onGetChannelMetadataResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onGetChannelMetadataResultCompleter.isCompleted) {
              onGetChannelMetadataResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onGetChannelMetadataResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onSetUserMetadataResult',
    (WidgetTester tester) async {
      final onSetUserMetadataResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onSetUserMetadataResult:
            (int requestId, String userId, RtmErrorCode errorCode) {
          onSetUserMetadataResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        String userId = "hello";
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onSetUserMetadataResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onSetUserMetadataResultCompleter.isCompleted) {
              onSetUserMetadataResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onSetUserMetadataResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onUpdateUserMetadataResult',
    (WidgetTester tester) async {
      final onUpdateUserMetadataResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onUpdateUserMetadataResult:
            (int requestId, String userId, RtmErrorCode errorCode) {
          onUpdateUserMetadataResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        String userId = "hello";
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onUpdateUserMetadataResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onUpdateUserMetadataResultCompleter.isCompleted) {
              onUpdateUserMetadataResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onUpdateUserMetadataResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onRemoveUserMetadataResult',
    (WidgetTester tester) async {
      final onRemoveUserMetadataResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onRemoveUserMetadataResult:
            (int requestId, String userId, RtmErrorCode errorCode) {
          onRemoveUserMetadataResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        String userId = "hello";
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onRemoveUserMetadataResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onRemoveUserMetadataResultCompleter.isCompleted) {
              onRemoveUserMetadataResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRemoveUserMetadataResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onGetUserMetadataResult',
    (WidgetTester tester) async {
      final onGetUserMetadataResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onGetUserMetadataResult: (int requestId, String userId, Metadata data,
            RtmErrorCode errorCode) {
          onGetUserMetadataResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        String userId = "hello";
        int dataMajorRevision = 5;
        List<MetadataItem> dataItems = [];
        int dataItemCount = 5;
        Metadata data = Metadata(
          majorRevision: dataMajorRevision,
          items: dataItems,
          itemCount: dataItemCount,
        );
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onGetUserMetadataResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onGetUserMetadataResultCompleter.isCompleted) {
              onGetUserMetadataResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onGetUserMetadataResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onSubscribeUserMetadataResult',
    (WidgetTester tester) async {
      final onSubscribeUserMetadataResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onSubscribeUserMetadataResult:
            (int requestId, String userId, RtmErrorCode errorCode) {
          onSubscribeUserMetadataResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        String userId = "hello";
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onSubscribeUserMetadataResult'] ??
                [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onSubscribeUserMetadataResultCompleter.isCompleted) {
              onSubscribeUserMetadataResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onSubscribeUserMetadataResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onUnsubscribeUserMetadataResult',
    (WidgetTester tester) async {
      final onUnsubscribeUserMetadataResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onUnsubscribeUserMetadataResult:
            (int requestId, String userId, RtmErrorCode errorCode) {
          onUnsubscribeUserMetadataResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        String userId = "hello";
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds = eventIdsMapping[
                'RtmEventHandler_onUnsubscribeUserMetadataResult'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onUnsubscribeUserMetadataResultCompleter.isCompleted) {
              onUnsubscribeUserMetadataResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onUnsubscribeUserMetadataResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onSetLockResult',
    (WidgetTester tester) async {
      final onSetLockResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onSetLockResult: (int requestId,
            String channelName,
            RtmChannelType channelType,
            String lockName,
            RtmErrorCode errorCode) {
          onSetLockResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        String channelName = "hello";
        RtmChannelType channelType = RtmChannelType.none;
        String lockName = "hello";
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onSetLockResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onSetLockResultCompleter.isCompleted) {
              onSetLockResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onSetLockResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onRemoveLockResult',
    (WidgetTester tester) async {
      final onRemoveLockResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onRemoveLockResult: (int requestId,
            String channelName,
            RtmChannelType channelType,
            String lockName,
            RtmErrorCode errorCode) {
          onRemoveLockResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        String channelName = "hello";
        RtmChannelType channelType = RtmChannelType.none;
        String lockName = "hello";
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onRemoveLockResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onRemoveLockResultCompleter.isCompleted) {
              onRemoveLockResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRemoveLockResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onReleaseLockResult',
    (WidgetTester tester) async {
      final onReleaseLockResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onReleaseLockResult: (int requestId,
            String channelName,
            RtmChannelType channelType,
            String lockName,
            RtmErrorCode errorCode) {
          onReleaseLockResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        String channelName = "hello";
        RtmChannelType channelType = RtmChannelType.none;
        String lockName = "hello";
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onReleaseLockResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onReleaseLockResultCompleter.isCompleted) {
              onReleaseLockResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onReleaseLockResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onAcquireLockResult',
    (WidgetTester tester) async {
      final onAcquireLockResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onAcquireLockResult: (int requestId,
            String channelName,
            RtmChannelType channelType,
            String lockName,
            RtmErrorCode errorCode,
            String errorDetails) {
          onAcquireLockResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        String channelName = "hello";
        RtmChannelType channelType = RtmChannelType.none;
        String lockName = "hello";
        RtmErrorCode errorCode = RtmErrorCode.ok;
        String errorDetails = "hello";

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onAcquireLockResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onAcquireLockResultCompleter.isCompleted) {
              onAcquireLockResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onAcquireLockResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onRevokeLockResult',
    (WidgetTester tester) async {
      final onRevokeLockResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onRevokeLockResult: (int requestId,
            String channelName,
            RtmChannelType channelType,
            String lockName,
            RtmErrorCode errorCode) {
          onRevokeLockResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        String channelName = "hello";
        RtmChannelType channelType = RtmChannelType.none;
        String lockName = "hello";
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onRevokeLockResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onRevokeLockResultCompleter.isCompleted) {
              onRevokeLockResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRevokeLockResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onGetLocksResult',
    (WidgetTester tester) async {
      final onGetLocksResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onGetLocksResult: (int requestId,
            String channelName,
            RtmChannelType channelType,
            List lockDetailList,
            int count,
            RtmErrorCode errorCode) {
          onGetLocksResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        String channelName = "hello";
        RtmChannelType channelType = RtmChannelType.none;
        final List<LockDetail> lockDetailList = () {
          String lockDetailListItemLockName = "hello";
          String lockDetailListItemOwner = "hello";
          int lockDetailListItemTtl = 5;
          LockDetail lockDetailListItem = LockDetail(
            lockName: lockDetailListItemLockName,
            owner: lockDetailListItemOwner,
            ttl: lockDetailListItemTtl,
          );

          return List.filled(5, lockDetailListItem);
        }();

        int count = 5;
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onGetLocksResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onGetLocksResultCompleter.isCompleted) {
              onGetLocksResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onGetLocksResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onWhoNowResult',
    (WidgetTester tester) async {
      final onWhoNowResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onWhoNowResult: (int requestId, List userStateList, int count,
            String nextPage, RtmErrorCode errorCode) {
          onWhoNowResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        final List<UserState> userStateList = () {
          String userStateListItemUserId = "hello";
          List<StateItem> userStateListItemStates = [];
          UserState userStateListItem = UserState(
            userId: userStateListItemUserId,
            states: userStateListItemStates,
          );

          return List.filled(5, userStateListItem);
        }();

        int count = 5;
        String nextPage = "hello";
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onWhoNowResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onWhoNowResultCompleter.isCompleted) {
              onWhoNowResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onWhoNowResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onGetOnlineUsersResult',
    (WidgetTester tester) async {
      final onGetOnlineUsersResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onGetOnlineUsersResult: (int requestId, List userStateList, int count,
            String nextPage, RtmErrorCode errorCode) {
          onGetOnlineUsersResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        final List<UserState> userStateList = () {
          String userStateListItemUserId = "hello";
          List<StateItem> userStateListItemStates = [];
          UserState userStateListItem = UserState(
            userId: userStateListItemUserId,
            states: userStateListItemStates,
          );

          return List.filled(5, userStateListItem);
        }();

        int count = 5;
        String nextPage = "hello";
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onGetOnlineUsersResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onGetOnlineUsersResultCompleter.isCompleted) {
              onGetOnlineUsersResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onGetOnlineUsersResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onWhereNowResult',
    (WidgetTester tester) async {
      final onWhereNowResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onWhereNowResult:
            (int requestId, List channels, int count, RtmErrorCode errorCode) {
          onWhereNowResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        final List<ChannelInfo> channels = () {
          RtmChannelType channelsItemChannelType = RtmChannelType.none;
          String channelsItemChannelName = "hello";
          ChannelInfo channelsItem = ChannelInfo(
            channelName: channelsItemChannelName,
            channelType: channelsItemChannelType,
          );

          return List.filled(5, channelsItem);
        }();

        int count = 5;
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onWhereNowResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onWhereNowResultCompleter.isCompleted) {
              onWhereNowResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onWhereNowResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onGetUserChannelsResult',
    (WidgetTester tester) async {
      final onGetUserChannelsResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onGetUserChannelsResult: (int requestId, ChannelInfo channels,
            int count, RtmErrorCode errorCode) {
          onGetUserChannelsResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        RtmChannelType channelsChannelType = RtmChannelType.none;
        String channelsChannelName = "hello";
        ChannelInfo channels = ChannelInfo(
          channelName: channelsChannelName,
          channelType: channelsChannelType,
        );
        int count = 5;
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onGetUserChannelsResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onGetUserChannelsResultCompleter.isCompleted) {
              onGetUserChannelsResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onGetUserChannelsResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onPresenceSetStateResult',
    (WidgetTester tester) async {
      final onPresenceSetStateResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onPresenceSetStateResult: (int requestId, RtmErrorCode errorCode) {
          onPresenceSetStateResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onPresenceSetStateResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onPresenceSetStateResultCompleter.isCompleted) {
              onPresenceSetStateResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onPresenceSetStateResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onPresenceRemoveStateResult',
    (WidgetTester tester) async {
      final onPresenceRemoveStateResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onPresenceRemoveStateResult: (int requestId, RtmErrorCode errorCode) {
          onPresenceRemoveStateResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onPresenceRemoveStateResult'] ??
                [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onPresenceRemoveStateResultCompleter.isCompleted) {
              onPresenceRemoveStateResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onPresenceRemoveStateResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtmEventHandler.onPresenceGetStateResult',
    (WidgetTester tester) async {
      final onPresenceGetStateResultCompleter = Completer<bool>();
      final theRtmEventHandler = RtmEventHandler(
        onPresenceGetStateResult:
            (int requestId, UserState state, RtmErrorCode errorCode) {
          onPresenceGetStateResultCompleter.complete(true);
        },
      );

      final rtmClient = await _createBindingRtmClient(theRtmEventHandler);

// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        int requestId = 5;
        String stateUserId = "hello";
        List<StateItem> stateStates = [];
        UserState state = UserState(
          userId: stateUserId,
          states: stateStates,
        );
        RtmErrorCode errorCode = RtmErrorCode.ok;

        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtmEventHandler_onPresenceGetStateResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onPresenceGetStateResultCompleter.isCompleted) {
              onPresenceGetStateResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onPresenceGetStateResultCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtmClient.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );
}
