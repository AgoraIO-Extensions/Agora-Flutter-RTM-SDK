/// GENERATED BY testcase_gen. DO NOT MODIFY BY HAND.

// ignore_for_file: deprecated_member_use,constant_identifier_names,unused_local_variable,unused_import,unnecessary_import

import 'package:agora_rtm/agora_rtm.dart';
import 'package:agora_rtm/src/impl/gen/agora_stream_channel_impl.dart'
    as stream_channel_impl;
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'dart:typed_data';

import '../all_mocks.mocks.dart';

void testCases() {
  test(
    'StreamChannel.join',
    () async {
      final mockStreamChannelNativeBinding = MockStreamChannelImpl();
      final mockRtmResultHandlerImpl = MockRtmResultHandlerImpl();
      StreamChannel streamChannel = stream_channel_impl.StreamChannelImpl(
        mockStreamChannelNativeBinding,
        mockRtmResultHandlerImpl,
      );

      const rtmStatus = RtmStatus.success(operation: 'join');
      String theJoinResultChannelName = "hello";
      String theJoinResultUserId = "hello";
      JoinResult theJoinResult = JoinResult(
        channelName: theJoinResultChannelName,
        userId: theJoinResultUserId,
      );
      final mockResultHandlerReturnValue = (theJoinResult, RtmErrorCode.ok);
      final expectedResultHandlerReturnValue = (rtmStatus, theJoinResult);
      int mockRequestId = 1;
      {
        String optionsToken = "hello";
        bool optionsWithMetadata = true;
        bool optionsWithPresence = true;
        bool optionsWithLock = true;
        bool optionsBeQuiet = true;
        JoinChannelOptions options = JoinChannelOptions(
          token: optionsToken,
          withMetadata: optionsWithMetadata,
          withPresence: optionsWithPresence,
          withLock: optionsWithLock,
          beQuiet: optionsBeQuiet,
        );
        when(mockStreamChannelNativeBinding.join(
          argThat(isA<JoinChannelOptions>()),
        )).thenAnswer((_) async => mockRequestId);
        when(mockRtmResultHandlerImpl.request(mockRequestId))
            .thenAnswer((_) async => mockResultHandlerReturnValue);
      }

      String token = "hello";
      bool withMetadata = true;
      bool withPresence = true;
      bool withLock = true;
      bool beQuiet = true;
      final ret = await streamChannel.join(
        token: token,
        withMetadata: withMetadata,
        withPresence: withPresence,
        withLock: withLock,
        beQuiet: beQuiet,
      );
      expect(ret, expectedResultHandlerReturnValue);
    },
  );

  test(
    'StreamChannel.renewToken',
    () async {
      final mockStreamChannelNativeBinding = MockStreamChannelImpl();
      final mockRtmResultHandlerImpl = MockRtmResultHandlerImpl();
      StreamChannel streamChannel = stream_channel_impl.StreamChannelImpl(
        mockStreamChannelNativeBinding,
        mockRtmResultHandlerImpl,
      );

      const rtmStatus = RtmStatus.success(operation: 'renewToken');
      RtmServiceType theRenewTokenResultServerType = RtmServiceType.none;
      String theRenewTokenResultChannelName = "hello";
      RenewTokenResult theRenewTokenResult = RenewTokenResult(
        serverType: theRenewTokenResultServerType,
        channelName: theRenewTokenResultChannelName,
      );
      final mockResultHandlerReturnValue =
          (theRenewTokenResult, RtmErrorCode.ok);
      final expectedResultHandlerReturnValue = (rtmStatus, theRenewTokenResult);
      int mockRequestId = 1;
      {
        String token = "hello";
        when(mockStreamChannelNativeBinding.renewToken(
          token,
        )).thenAnswer((_) async => mockRequestId);
        when(mockRtmResultHandlerImpl.request(mockRequestId))
            .thenAnswer((_) async => mockResultHandlerReturnValue);
      }

      String token = "hello";
      final ret = await streamChannel.renewToken(
        token,
      );
      expect(ret, expectedResultHandlerReturnValue);
    },
  );

  test(
    'StreamChannel.leave',
    () async {
      final mockStreamChannelNativeBinding = MockStreamChannelImpl();
      final mockRtmResultHandlerImpl = MockRtmResultHandlerImpl();
      StreamChannel streamChannel = stream_channel_impl.StreamChannelImpl(
        mockStreamChannelNativeBinding,
        mockRtmResultHandlerImpl,
      );

      const rtmStatus = RtmStatus.success(operation: 'leave');
      String theLeaveResultChannelName = "hello";
      String theLeaveResultUserId = "hello";
      LeaveResult theLeaveResult = LeaveResult(
        channelName: theLeaveResultChannelName,
        userId: theLeaveResultUserId,
      );
      final mockResultHandlerReturnValue = (theLeaveResult, RtmErrorCode.ok);
      final expectedResultHandlerReturnValue = (rtmStatus, theLeaveResult);
      int mockRequestId = 1;
      {
        when(mockStreamChannelNativeBinding.leave())
            .thenAnswer((_) async => mockRequestId);
        when(mockRtmResultHandlerImpl.request(mockRequestId))
            .thenAnswer((_) async => mockResultHandlerReturnValue);
      }

      final ret = await streamChannel.leave();
      expect(ret, expectedResultHandlerReturnValue);
    },
  );

  test(
    'StreamChannel.getChannelName',
    () async {
      final mockStreamChannelNativeBinding = MockStreamChannelImpl();
      final mockRtmResultHandlerImpl = MockRtmResultHandlerImpl();
      StreamChannel streamChannel = stream_channel_impl.StreamChannelImpl(
        mockStreamChannelNativeBinding,
        mockRtmResultHandlerImpl,
      );

      String theString = "hello";
      {
        when(mockStreamChannelNativeBinding.getChannelName())
            .thenAnswer((_) async => theString);
      }

      await streamChannel.getChannelName();
    },
  );

  test(
    'StreamChannel.joinTopic',
    () async {
      final mockStreamChannelNativeBinding = MockStreamChannelImpl();
      final mockRtmResultHandlerImpl = MockRtmResultHandlerImpl();
      StreamChannel streamChannel = stream_channel_impl.StreamChannelImpl(
        mockStreamChannelNativeBinding,
        mockRtmResultHandlerImpl,
      );

      const rtmStatus = RtmStatus.success(operation: 'joinTopic');
      String theJoinTopicResultChannelName = "hello";
      String theJoinTopicResultUserId = "hello";
      String theJoinTopicResultTopic = "hello";
      String theJoinTopicResultMeta = "hello";
      JoinTopicResult theJoinTopicResult = JoinTopicResult(
        channelName: theJoinTopicResultChannelName,
        userId: theJoinTopicResultUserId,
        topic: theJoinTopicResultTopic,
        meta: theJoinTopicResultMeta,
      );
      final mockResultHandlerReturnValue =
          (theJoinTopicResult, RtmErrorCode.ok);
      final expectedResultHandlerReturnValue = (rtmStatus, theJoinTopicResult);
      int mockRequestId = 1;
      {
        String topic = "hello";
        RtmMessageQos optionsQos = RtmMessageQos.unordered;
        RtmMessagePriority optionsPriority = RtmMessagePriority.highest;
        String optionsMeta = "hello";
        bool optionsSyncWithMedia = true;
        JoinTopicOptions options = JoinTopicOptions(
          qos: optionsQos,
          priority: optionsPriority,
          meta: optionsMeta,
          syncWithMedia: optionsSyncWithMedia,
        );
        when(mockStreamChannelNativeBinding.joinTopic(
          topic: topic,
          options: argThat(
            isA<JoinTopicOptions>(),
            named: 'options',
          ),
        )).thenAnswer((_) async => mockRequestId);
        when(mockRtmResultHandlerImpl.request(mockRequestId))
            .thenAnswer((_) async => mockResultHandlerReturnValue);
      }

      String topic = "hello";
      RtmMessageQos qos = RtmMessageQos.unordered;
      RtmMessagePriority priority = RtmMessagePriority.highest;
      String meta = "hello";
      bool syncWithMedia = true;
      final ret = await streamChannel.joinTopic(
        topic,
        qos: qos,
        priority: priority,
        meta: meta,
        syncWithMedia: syncWithMedia,
      );
      expect(ret, expectedResultHandlerReturnValue);
    },
  );

  test(
    'StreamChannel.leaveTopic',
    () async {
      final mockStreamChannelNativeBinding = MockStreamChannelImpl();
      final mockRtmResultHandlerImpl = MockRtmResultHandlerImpl();
      StreamChannel streamChannel = stream_channel_impl.StreamChannelImpl(
        mockStreamChannelNativeBinding,
        mockRtmResultHandlerImpl,
      );

      const rtmStatus = RtmStatus.success(operation: 'leaveTopic');
      String theLeaveTopicResultChannelName = "hello";
      String theLeaveTopicResultUserId = "hello";
      String theLeaveTopicResultTopic = "hello";
      String theLeaveTopicResultMeta = "hello";
      LeaveTopicResult theLeaveTopicResult = LeaveTopicResult(
        channelName: theLeaveTopicResultChannelName,
        userId: theLeaveTopicResultUserId,
        topic: theLeaveTopicResultTopic,
        meta: theLeaveTopicResultMeta,
      );
      final mockResultHandlerReturnValue =
          (theLeaveTopicResult, RtmErrorCode.ok);
      final expectedResultHandlerReturnValue = (rtmStatus, theLeaveTopicResult);
      int mockRequestId = 1;
      {
        String topic = "hello";
        when(mockStreamChannelNativeBinding.leaveTopic(
          topic,
        )).thenAnswer((_) async => mockRequestId);
        when(mockRtmResultHandlerImpl.request(mockRequestId))
            .thenAnswer((_) async => mockResultHandlerReturnValue);
      }

      String topic = "hello";
      final ret = await streamChannel.leaveTopic(
        topic,
      );
      expect(ret, expectedResultHandlerReturnValue);
    },
  );

  test(
    'StreamChannel.subscribeTopic',
    () async {
      final mockStreamChannelNativeBinding = MockStreamChannelImpl();
      final mockRtmResultHandlerImpl = MockRtmResultHandlerImpl();
      StreamChannel streamChannel = stream_channel_impl.StreamChannelImpl(
        mockStreamChannelNativeBinding,
        mockRtmResultHandlerImpl,
      );

      const rtmStatus = RtmStatus.success(operation: 'subscribeTopic');
      String theSubscribeTopicResultChannelName = "hello";
      String theSubscribeTopicResultUserId = "hello";
      String theSubscribeTopicResultTopic = "hello";
      List<String> theSubscribeTopicResultSucceedUsers =
          List.filled(5, "hello");
      List<String> theSubscribeTopicResultFailedUsers = List.filled(5, "hello");
      SubscribeTopicResult theSubscribeTopicResult = SubscribeTopicResult(
        channelName: theSubscribeTopicResultChannelName,
        userId: theSubscribeTopicResultUserId,
        topic: theSubscribeTopicResultTopic,
        succeedUsers: theSubscribeTopicResultSucceedUsers,
        failedUsers: theSubscribeTopicResultFailedUsers,
      );
      final mockResultHandlerReturnValue =
          (theSubscribeTopicResult, RtmErrorCode.ok);
      final expectedResultHandlerReturnValue =
          (rtmStatus, theSubscribeTopicResult);
      int mockRequestId = 1;
      {
        String topic = "hello";
        List<String> optionsUsers = List.filled(5, "hello");
        int optionsUserCount = 5;
        TopicOptions options = TopicOptions(
          users: optionsUsers,
          userCount: optionsUserCount,
        );
        when(mockStreamChannelNativeBinding.subscribeTopic(
          topic: topic,
          options: argThat(
            isA<TopicOptions>(),
            named: 'options',
          ),
        )).thenAnswer((_) async => mockRequestId);
        when(mockRtmResultHandlerImpl.request(mockRequestId))
            .thenAnswer((_) async => mockResultHandlerReturnValue);
      }

      String topic = "hello";
      List<String> users = List.filled(5, "hello");
      final ret = await streamChannel.subscribeTopic(
        topic,
        users: users,
      );
      expect(ret, expectedResultHandlerReturnValue);
    },
  );

  test(
    'StreamChannel.unsubscribeTopic',
    () async {
      final mockStreamChannelNativeBinding = MockStreamChannelImpl();
      final mockRtmResultHandlerImpl = MockRtmResultHandlerImpl();
      StreamChannel streamChannel = stream_channel_impl.StreamChannelImpl(
        mockStreamChannelNativeBinding,
        mockRtmResultHandlerImpl,
      );

      const rtmStatus = RtmStatus.success(operation: 'unsubscribeTopic');
      String theUnsubscribeTopicResultChannelName = "hello";
      String theUnsubscribeTopicResultTopic = "hello";
      UnsubscribeTopicResult theUnsubscribeTopicResult = UnsubscribeTopicResult(
        channelName: theUnsubscribeTopicResultChannelName,
        topic: theUnsubscribeTopicResultTopic,
      );
      final mockResultHandlerReturnValue =
          (theUnsubscribeTopicResult, RtmErrorCode.ok);
      final expectedResultHandlerReturnValue =
          (rtmStatus, theUnsubscribeTopicResult);
      int mockRequestId = 1;
      {
        String topic = "hello";
        List<String> optionsUsers = List.filled(5, "hello");
        int optionsUserCount = 5;
        TopicOptions options = TopicOptions(
          users: optionsUsers,
          userCount: optionsUserCount,
        );
        when(mockStreamChannelNativeBinding.unsubscribeTopic(
          topic: topic,
          options: argThat(
            isA<TopicOptions>(),
            named: 'options',
          ),
        )).thenAnswer((_) async => mockRequestId);
        when(mockRtmResultHandlerImpl.request(mockRequestId))
            .thenAnswer((_) async => mockResultHandlerReturnValue);
      }

      String topic = "hello";
      List<String> users = List.filled(5, "hello");
      final ret = await streamChannel.unsubscribeTopic(
        topic,
        users: users,
      );
      expect(ret, expectedResultHandlerReturnValue);
    },
  );

  test(
    'StreamChannel.getSubscribedUserList',
    () async {
      final mockStreamChannelNativeBinding = MockStreamChannelImpl();
      final mockRtmResultHandlerImpl = MockRtmResultHandlerImpl();
      StreamChannel streamChannel = stream_channel_impl.StreamChannelImpl(
        mockStreamChannelNativeBinding,
        mockRtmResultHandlerImpl,
      );

      const rtmStatus = RtmStatus.success(operation: 'getSubscribedUserList');
      List<String> usersUsers = List.filled(5, "hello");
      UserList theGetSubscribedUserListResultUsers = UserList(
        users: usersUsers,
      );
      String theGetSubscribedUserListResultChannelName = "hello";
      String theGetSubscribedUserListResultTopic = "hello";
      GetSubscribedUserListResult theGetSubscribedUserListResult =
          GetSubscribedUserListResult(
        channelName: theGetSubscribedUserListResultChannelName,
        topic: theGetSubscribedUserListResultTopic,
        users: theGetSubscribedUserListResultUsers,
      );
      final mockResultHandlerReturnValue =
          (theGetSubscribedUserListResult, RtmErrorCode.ok);
      final expectedResultHandlerReturnValue =
          (rtmStatus, theGetSubscribedUserListResult);
      int mockRequestId = 1;
      {
        String topic = "hello";
        when(mockStreamChannelNativeBinding.getSubscribedUserList(
          topic,
        )).thenAnswer((_) async => mockRequestId);
        when(mockRtmResultHandlerImpl.request(mockRequestId))
            .thenAnswer((_) async => mockResultHandlerReturnValue);
      }

      String topic = "hello";
      final ret = await streamChannel.getSubscribedUserList(
        topic,
      );
      expect(ret, expectedResultHandlerReturnValue);
    },
  );

  test(
    'StreamChannel.release',
    () async {
      final mockStreamChannelNativeBinding = MockStreamChannelImpl();
      final mockRtmResultHandlerImpl = MockRtmResultHandlerImpl();
      StreamChannel streamChannel = stream_channel_impl.StreamChannelImpl(
        mockStreamChannelNativeBinding,
        mockRtmResultHandlerImpl,
      );

      {}

      await streamChannel.release();
    },
  );

  test(
    'StreamChannel.publishTextMessage',
    () async {
      final mockStreamChannelNativeBinding = MockStreamChannelImpl();
      final mockRtmResultHandlerImpl = MockRtmResultHandlerImpl();
      StreamChannel streamChannel = stream_channel_impl.StreamChannelImpl(
        mockStreamChannelNativeBinding,
        mockRtmResultHandlerImpl,
      );

      const rtmStatus = RtmStatus.success(operation: 'publishTextMessage');
      String thePublishTopicMessageResultChannelName = "hello";
      String thePublishTopicMessageResultTopic = "hello";
      PublishTopicMessageResult thePublishTopicMessageResult =
          PublishTopicMessageResult(
        channelName: thePublishTopicMessageResultChannelName,
        topic: thePublishTopicMessageResultTopic,
      );
      final mockResultHandlerReturnValue =
          (thePublishTopicMessageResult, RtmErrorCode.ok);
      final expectedResultHandlerReturnValue =
          (rtmStatus, thePublishTopicMessageResult);
      int mockRequestId = 1;
      {
        String topic = "hello";
        String message = "hello";
        int length = 5;
        RtmMessageType optionMessageType = RtmMessageType.binary;
        int optionSendTs = 5;
        String optionCustomType = "hello";
        TopicMessageOptions option = TopicMessageOptions(
          messageType: optionMessageType,
          sendTs: optionSendTs,
          customType: optionCustomType,
        );
        when(mockStreamChannelNativeBinding.publishTextMessage(
          topic: topic,
          message: message,
          length: length,
          option: argThat(
            isA<TopicMessageOptions>(),
            named: 'option',
          ),
        )).thenAnswer((_) async => mockRequestId);
        when(mockRtmResultHandlerImpl.request(mockRequestId))
            .thenAnswer((_) async => mockResultHandlerReturnValue);
      }

      String topic = "hello";
      String message = "hello";
      int sendTs = 5;
      String customType = "hello";
      final ret = await streamChannel.publishTextMessage(
        topic,
        message,
        sendTs: sendTs,
        customType: customType,
      );
      expect(ret, expectedResultHandlerReturnValue);
    },
  );

  test(
    'StreamChannel.publishBinaryMessage',
    () async {
      final mockStreamChannelNativeBinding = MockStreamChannelImpl();
      final mockRtmResultHandlerImpl = MockRtmResultHandlerImpl();
      StreamChannel streamChannel = stream_channel_impl.StreamChannelImpl(
        mockStreamChannelNativeBinding,
        mockRtmResultHandlerImpl,
      );

      const rtmStatus = RtmStatus.success(operation: 'publishBinaryMessage');
      String thePublishTopicMessageResultChannelName = "hello";
      String thePublishTopicMessageResultTopic = "hello";
      PublishTopicMessageResult thePublishTopicMessageResult =
          PublishTopicMessageResult(
        channelName: thePublishTopicMessageResultChannelName,
        topic: thePublishTopicMessageResultTopic,
      );
      final mockResultHandlerReturnValue =
          (thePublishTopicMessageResult, RtmErrorCode.ok);
      final expectedResultHandlerReturnValue =
          (rtmStatus, thePublishTopicMessageResult);
      int mockRequestId = 1;
      {
        String topic = "hello";
        Uint8List message = Uint8List.fromList([1, 1, 1, 1, 1]);
        int length = 5;
        RtmMessageType optionMessageType = RtmMessageType.binary;
        int optionSendTs = 5;
        String optionCustomType = "hello";
        TopicMessageOptions option = TopicMessageOptions(
          messageType: optionMessageType,
          sendTs: optionSendTs,
          customType: optionCustomType,
        );
        when(mockStreamChannelNativeBinding.publishBinaryMessage(
          topic: topic,
          message: message,
          length: length,
          option: argThat(
            isA<TopicMessageOptions>(),
            named: 'option',
          ),
        )).thenAnswer((_) async => mockRequestId);
        when(mockRtmResultHandlerImpl.request(mockRequestId))
            .thenAnswer((_) async => mockResultHandlerReturnValue);
      }

      String topic = "hello";
      Uint8List message = Uint8List.fromList([1, 1, 1, 1, 1]);
      int sendTs = 5;
      String customType = "hello";
      final ret = await streamChannel.publishBinaryMessage(
        topic,
        message,
        sendTs: sendTs,
        customType: customType,
      );
      expect(ret, expectedResultHandlerReturnValue);
    },
  );
}
