/// GENERATED BY terra, DO NOT MODIFY BY HAND.

// ignore_for_file: public_member_api_docs, unused_local_variable, unused_import, annotate_overrides

import 'binding_forward_export.dart';
import 'package:iris_method_channel/iris_method_channel.dart';

class RtmPresenceImpl implements RtmPresence {
  RtmPresenceImpl(this.irisMethodChannel);

  final IrisMethodChannel irisMethodChannel;

  @protected
  Map<String, dynamic> createParams(Map<String, dynamic> param) {
    return param;
  }

  @protected
  bool get isOverrideClassName => false;

  @protected
  String get className => 'RtmPresence';

  @override
  Future<int> whoNow(
      {required String channelName,
      required RtmChannelType channelType,
      required PresenceOptions options}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtmPresence'}_whoNow_f7f61d1';
    final param = createParams({
      'channelName': channelName,
      'channelType': channelType.value(),
      'options': options.toJson()
    });
    final List<Uint8List> buffers = [];
    buffers.addAll(options.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throwExceptionHandler(code: result);
    }
    final whoNowJson = RtmPresenceWhoNowJson.fromJson(rm);
    return whoNowJson.requestId;
  }

  @override
  Future<int> whereNow(String userId) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtmPresence'}_whereNow_1fa04dd';
    final param = createParams({'userId': userId});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throwExceptionHandler(code: result);
    }
    final whereNowJson = RtmPresenceWhereNowJson.fromJson(rm);
    return whereNowJson.requestId;
  }

  @override
  Future<int> setState(
      {required String channelName,
      required RtmChannelType channelType,
      required List<StateItem> items,
      required int count}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtmPresence'}_setState_b73723a';
    final itemsJsonList = items.map((e) => e.toJson()).toList();
    final param = createParams({
      'channelName': channelName,
      'channelType': channelType.value(),
      'items': itemsJsonList,
      'count': count
    });
    final List<Uint8List> buffers = [];
    for (final e in items) {
      buffers.addAll(e.collectBufferList());
    }
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throwExceptionHandler(code: result);
    }
    final setStateJson = RtmPresenceSetStateJson.fromJson(rm);
    return setStateJson.requestId;
  }

  @override
  Future<int> removeState(
      {required String channelName,
      required RtmChannelType channelType,
      required List<String> keys,
      required int count}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtmPresence'}_removeState_d7033d8';
    final param = createParams({
      'channelName': channelName,
      'channelType': channelType.value(),
      'keys': keys,
      'count': count
    });
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throwExceptionHandler(code: result);
    }
    final removeStateJson = RtmPresenceRemoveStateJson.fromJson(rm);
    return removeStateJson.requestId;
  }

  @override
  Future<int> getState(
      {required String channelName,
      required RtmChannelType channelType,
      required String userId}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtmPresence'}_getState_4ffa44d';
    final param = createParams({
      'channelName': channelName,
      'channelType': channelType.value(),
      'userId': userId
    });
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throwExceptionHandler(code: result);
    }
    final getStateJson = RtmPresenceGetStateJson.fromJson(rm);
    return getStateJson.requestId;
  }

  @override
  Future<int> getOnlineUsers(
      {required String channelName,
      required RtmChannelType channelType,
      required GetOnlineUsersOptions options}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtmPresence'}_getOnlineUsers_ce2d8e8';
    final param = createParams({
      'channelName': channelName,
      'channelType': channelType.value(),
      'options': options.toJson()
    });
    final List<Uint8List> buffers = [];
    buffers.addAll(options.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throwExceptionHandler(code: result);
    }
    final getOnlineUsersJson = RtmPresenceGetOnlineUsersJson.fromJson(rm);
    return getOnlineUsersJson.requestId;
  }

  @override
  Future<int> getUserChannels(String userId) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtmPresence'}_getUserChannels_1fa04dd';
    final param = createParams({'userId': userId});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throwExceptionHandler(code: result);
    }
    final getUserChannelsJson = RtmPresenceGetUserChannelsJson.fromJson(rm);
    return getUserChannelsJson.requestId;
  }
}
