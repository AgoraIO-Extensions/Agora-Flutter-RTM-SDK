/// GENERATED BY terra, DO NOT MODIFY BY HAND.

// ignore_for_file: public_member_api_docs, unused_local_variable, unused_import, annotate_overrides

import 'binding_forward_export.dart';
import 'package:iris_method_channel/iris_method_channel.dart';

class StreamChannelImpl implements StreamChannel {
  StreamChannelImpl(this.irisMethodChannel);

  final IrisMethodChannel irisMethodChannel;

  @protected
  Map<String, dynamic> createParams(Map<String, dynamic> param) {
    return param;
  }

  @protected
  bool get isOverrideClassName => false;

  @protected
  String get className => 'StreamChannel';

  @override
  Future<int> join(JoinChannelOptions options) async {
    final apiType =
        '${isOverrideClassName ? className : 'StreamChannel'}_join_2090a6b';
    final param = createParams({'options': options.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(options.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throwExceptionHandler(code: result);
    }
    final joinJson = StreamChannelJoinJson.fromJson(rm);
    return joinJson.requestId;
  }

  @override
  Future<int> renewToken(String token) async {
    final apiType =
        '${isOverrideClassName ? className : 'StreamChannel'}_renewToken_1fa04dd';
    final param = createParams({'token': token});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throwExceptionHandler(code: result);
    }
    final renewTokenJson = StreamChannelRenewTokenJson.fromJson(rm);
    return renewTokenJson.requestId;
  }

  @override
  Future<int> leave() async {
    final apiType =
        '${isOverrideClassName ? className : 'StreamChannel'}_leave_90386a9';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throwExceptionHandler(code: result);
    }
    final leaveJson = StreamChannelLeaveJson.fromJson(rm);
    return leaveJson.requestId;
  }

  @override
  Future<String> getChannelName() async {
    final apiType =
        '${isOverrideClassName ? className : 'StreamChannel'}_getChannelName';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as String;
  }

  @override
  Future<int> joinTopic(
      {required String topic, required JoinTopicOptions options}) async {
    final apiType =
        '${isOverrideClassName ? className : 'StreamChannel'}_joinTopic_ff0ec3f';
    final param = createParams({'topic': topic, 'options': options.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(options.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throwExceptionHandler(code: result);
    }
    final joinTopicJson = StreamChannelJoinTopicJson.fromJson(rm);
    return joinTopicJson.requestId;
  }

  @override
  Future<int> publishTopicMessage(
      {required String topic,
      required String message,
      required int length,
      required TopicMessageOptions option}) async {
    final apiType =
        '${isOverrideClassName ? className : 'StreamChannel'}_publishTopicMessage_a31773e';
    final param = createParams({
      'topic': topic,
      'message': message,
      'length': length,
      'option': option.toJson()
    });
    final List<Uint8List> buffers = [];
    buffers.addAll(option.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throwExceptionHandler(code: result);
    }
    final publishTopicMessageJson =
        StreamChannelPublishTopicMessageJson.fromJson(rm);
    return publishTopicMessageJson.requestId;
  }

  @override
  Future<int> leaveTopic(String topic) async {
    final apiType =
        '${isOverrideClassName ? className : 'StreamChannel'}_leaveTopic_1fa04dd';
    final param = createParams({'topic': topic});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throwExceptionHandler(code: result);
    }
    final leaveTopicJson = StreamChannelLeaveTopicJson.fromJson(rm);
    return leaveTopicJson.requestId;
  }

  @override
  Future<int> subscribeTopic(
      {required String topic, required TopicOptions options}) async {
    final apiType =
        '${isOverrideClassName ? className : 'StreamChannel'}_subscribeTopic_b801234';
    final param = createParams({'topic': topic, 'options': options.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(options.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throwExceptionHandler(code: result);
    }
    final subscribeTopicJson = StreamChannelSubscribeTopicJson.fromJson(rm);
    return subscribeTopicJson.requestId;
  }

  @override
  Future<int> unsubscribeTopic(
      {required String topic, required TopicOptions options}) async {
    final apiType =
        '${isOverrideClassName ? className : 'StreamChannel'}_unsubscribeTopic_b801234';
    final param = createParams({'topic': topic, 'options': options.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(options.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throwExceptionHandler(code: result);
    }
    final unsubscribeTopicJson = StreamChannelUnsubscribeTopicJson.fromJson(rm);
    return unsubscribeTopicJson.requestId;
  }

  @override
  Future<int> getSubscribedUserList(String topic) async {
    final apiType =
        '${isOverrideClassName ? className : 'StreamChannel'}_getSubscribedUserList_1fa04dd';
    final param = createParams({'topic': topic});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throwExceptionHandler(code: result);
    }
    final getSubscribedUserListJson =
        StreamChannelGetSubscribedUserListJson.fromJson(rm);
    return getSubscribedUserListJson.requestId;
  }

  @override
  Future<void> release() async {
    final apiType =
        '${isOverrideClassName ? className : 'StreamChannel'}_release';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throwExceptionHandler(code: result);
    }
  }

  @override
  Future<int> publishTextMessage(
      {required String topic,
      required String message,
      required int length,
      required TopicMessageOptions option}) async {
    final apiType =
        '${isOverrideClassName ? className : 'StreamChannel'}_publishTopicMessage_a31773e';
    final param = createParams({
      'topic': topic,
      'message': message,
      'length': length,
      'option': option.toJson()
    });
    final List<Uint8List> buffers = [];
    buffers.addAll(option.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throwExceptionHandler(code: result);
    }
    final publishTextMessageJson =
        StreamChannelPublishTextMessageJson.fromJson(rm);
    return publishTextMessageJson.requestId;
  }

  @override
  Future<int> publishBinaryMessage(
      {required String topic,
      required Uint8List message,
      required int length,
      required TopicMessageOptions option}) async {
    final apiType =
        '${isOverrideClassName ? className : 'StreamChannel'}_publishTopicMessage_a31773e';
    final param = createParams(
        {'topic': topic, 'length': length, 'option': option.toJson()});
    final List<Uint8List> buffers = [];
    buffers.add(message);
    buffers.addAll(option.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throwExceptionHandler(code: result);
    }
    final publishBinaryMessageJson =
        StreamChannelPublishBinaryMessageJson.fromJson(rm);
    return publishBinaryMessageJson.requestId;
  }
}
