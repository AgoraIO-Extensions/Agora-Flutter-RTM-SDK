/// GENERATED BY terra, DO NOT MODIFY BY HAND.

// ignore_for_file: public_member_api_docs, unused_local_variable, unused_import, annotate_overrides

import 'binding_forward_export.dart';
import 'package:iris_method_channel/iris_method_channel.dart';

class RtmStorageImpl implements RtmStorage {
  RtmStorageImpl(this.irisMethodChannel);

  final IrisMethodChannel irisMethodChannel;

  @protected
  Map<String, dynamic> createParams(Map<String, dynamic> param) {
    return param;
  }

  @protected
  bool get isOverrideClassName => false;

  @protected
  String get className => 'RtmStorage';

  @override
  Future<int> setChannelMetadata(
      {required String channelName,
      required RtmChannelType channelType,
      required Metadata data,
      required MetadataOptions options,
      required String lockName}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtmStorage'}_setChannelMetadata_55e6d00';
    final param = createParams({
      'channelName': channelName,
      'channelType': channelType.value(),
      'data': data.toJson(),
      'options': options.toJson(),
      'lockName': lockName
    });
    final List<Uint8List> buffers = [];
    buffers.addAll(data.collectBufferList());
    buffers.addAll(options.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throwExceptionHandler(code: result);
    }
    final setChannelMetadataJson =
        RtmStorageSetChannelMetadataJson.fromJson(rm);
    return setChannelMetadataJson.requestId;
  }

  @override
  Future<int> updateChannelMetadata(
      {required String channelName,
      required RtmChannelType channelType,
      required Metadata data,
      required MetadataOptions options,
      required String lockName}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtmStorage'}_updateChannelMetadata_55e6d00';
    final param = createParams({
      'channelName': channelName,
      'channelType': channelType.value(),
      'data': data.toJson(),
      'options': options.toJson(),
      'lockName': lockName
    });
    final List<Uint8List> buffers = [];
    buffers.addAll(data.collectBufferList());
    buffers.addAll(options.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throwExceptionHandler(code: result);
    }
    final updateChannelMetadataJson =
        RtmStorageUpdateChannelMetadataJson.fromJson(rm);
    return updateChannelMetadataJson.requestId;
  }

  @override
  Future<int> removeChannelMetadata(
      {required String channelName,
      required RtmChannelType channelType,
      required Metadata data,
      required MetadataOptions options,
      required String lockName}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtmStorage'}_removeChannelMetadata_55e6d00';
    final param = createParams({
      'channelName': channelName,
      'channelType': channelType.value(),
      'data': data.toJson(),
      'options': options.toJson(),
      'lockName': lockName
    });
    final List<Uint8List> buffers = [];
    buffers.addAll(data.collectBufferList());
    buffers.addAll(options.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throwExceptionHandler(code: result);
    }
    final removeChannelMetadataJson =
        RtmStorageRemoveChannelMetadataJson.fromJson(rm);
    return removeChannelMetadataJson.requestId;
  }

  @override
  Future<int> getChannelMetadata(
      {required String channelName,
      required RtmChannelType channelType}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtmStorage'}_getChannelMetadata_ad8568b';
    final param = createParams(
        {'channelName': channelName, 'channelType': channelType.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throwExceptionHandler(code: result);
    }
    final getChannelMetadataJson =
        RtmStorageGetChannelMetadataJson.fromJson(rm);
    return getChannelMetadataJson.requestId;
  }

  @override
  Future<int> setUserMetadata(
      {required String userId,
      required Metadata data,
      required MetadataOptions options}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtmStorage'}_setUserMetadata_24ae125';
    final param = createParams(
        {'userId': userId, 'data': data.toJson(), 'options': options.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(data.collectBufferList());
    buffers.addAll(options.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throwExceptionHandler(code: result);
    }
    final setUserMetadataJson = RtmStorageSetUserMetadataJson.fromJson(rm);
    return setUserMetadataJson.requestId;
  }

  @override
  Future<int> updateUserMetadata(
      {required String userId,
      required Metadata data,
      required MetadataOptions options}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtmStorage'}_updateUserMetadata_24ae125';
    final param = createParams(
        {'userId': userId, 'data': data.toJson(), 'options': options.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(data.collectBufferList());
    buffers.addAll(options.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throwExceptionHandler(code: result);
    }
    final updateUserMetadataJson =
        RtmStorageUpdateUserMetadataJson.fromJson(rm);
    return updateUserMetadataJson.requestId;
  }

  @override
  Future<int> removeUserMetadata(
      {required String userId,
      required Metadata data,
      required MetadataOptions options}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtmStorage'}_removeUserMetadata_24ae125';
    final param = createParams(
        {'userId': userId, 'data': data.toJson(), 'options': options.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(data.collectBufferList());
    buffers.addAll(options.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throwExceptionHandler(code: result);
    }
    final removeUserMetadataJson =
        RtmStorageRemoveUserMetadataJson.fromJson(rm);
    return removeUserMetadataJson.requestId;
  }

  @override
  Future<int> getUserMetadata(String userId) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtmStorage'}_getUserMetadata_1fa04dd';
    final param = createParams({'userId': userId});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throwExceptionHandler(code: result);
    }
    final getUserMetadataJson = RtmStorageGetUserMetadataJson.fromJson(rm);
    return getUserMetadataJson.requestId;
  }

  @override
  Future<int> subscribeUserMetadata(String userId) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtmStorage'}_subscribeUserMetadata_1fa04dd';
    final param = createParams({'userId': userId});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throwExceptionHandler(code: result);
    }
    final subscribeUserMetadataJson =
        RtmStorageSubscribeUserMetadataJson.fromJson(rm);
    return subscribeUserMetadataJson.requestId;
  }

  @override
  Future<int> unsubscribeUserMetadata(String userId) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtmStorage'}_unsubscribeUserMetadata_1fa04dd';
    final param = createParams({'userId': userId});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throwExceptionHandler(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throwExceptionHandler(code: result);
    }
    final unsubscribeUserMetadataJson =
        RtmStorageUnsubscribeUserMetadataJson.fromJson(rm);
    return unsubscribeUserMetadataJson.requestId;
  }
}
